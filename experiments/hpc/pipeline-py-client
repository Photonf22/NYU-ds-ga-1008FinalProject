#!/usr/bin/env python3
"""Client for orchestrating WeJEPA pipelines.

This client depends on the ``dialog`` binary install it via your package manager (e.g.,
``apt-get install dialog``) before launching the UI.
"""

from __future__ import annotations

import argparse
import json
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Dict, Iterable, List, Sequence, Tuple
import os

ROOT = Path(__file__).resolve().parent

GLOBAL_EXP_DIR = Path(os.environ.get("WEJEPA_EXP") or (ROOT.parent)).resolve()
PROJECT_DIR = GLOBAL_EXP_DIR.parent
SETTINGS = PROJECT_DIR / ".wejepa_config.json"

CONFIGS_DIR = GLOBAL_EXP_DIR / "configs"
SLURMS_DIR = GLOBAL_EXP_DIR / "hpc" / "slurms"
DATA_DIR = GLOBAL_EXP_DIR / "data"

# Ensure directories exist
CONFIGS_DIR.mkdir(parents=True, exist_ok=True)
SLURMS_DIR.mkdir(parents=True, exist_ok=True)
DATA_DIR.mkdir(parents=True, exist_ok=True)

SLURM_TEMPLATE = SLURMS_DIR / "sbatch_pretrain.slurm"
DATASET_CHOICES: Tuple[Tuple[str, str], ...] = (
    ("cifar100", "CIFAR100"),
    ("tsbpp/fall2025_deeplearning", "tsbpp/fall2025_deeplearning"),
    ("LAION-5B", "LAION-5B"),
    ("open_images", "open_images"),
    ("imagenet", "imagenet"),
    ("mscoco", "mscoco"),
    ("common_pool", "common_pool"),
    ("unsplash", "unsplash"),
)

def load_config():
    if SETTINGS.exists():
        try:
            return json.loads(SETTINGS.read_text())
        except Exception:
            return {}
    return {}

def save_config(cfg):
    SETTINGS.write_text(json.dumps(cfg, indent=2))

config = load_config()

# First-time setup: create alias if not already done
def ensure_alias_setup():
    # check for zsh vs sh
    shell_rc = Path.home() / ".zshrc" if (Path.home() / ".zshrc").exists() else Path.home() / ".bashrc"
    if config.get("alias_setup_done", False):
        return
    alias_line = f"alias wejepa=\"{str(ROOT / 'pipeline-py-client')}\""

    if shell_rc.exists():
        lines = shell_rc.read_text().splitlines()
        if not any("alias wejepa=" in line for line in lines):
            with shell_rc.open("a") as f:
                f.write(f"\n# Alias for WeJEPA pipeline client\n{alias_line}\n")
            print(f"Added alias to {shell_rc}: {alias_line}")
    config["alias_setup_done"] = True
    save_config(config)

ensure_alias_setup()

class DialogCancelled(Exception):
    """Raised when the user cancels or presses ESC in a dialog."""


def format_command(command: Sequence[str]) -> str:
    """Render a command list as a shell-friendly string."""

    return " ".join(command)


def run_command(command: Sequence[str], dry_run: bool = False, ui: 'DialogUI' = None) -> None:
    """Execute a command list, respecting dry-run mode. If ui is provided and dry-run, show in dialog."""
    printable = format_command(command)
    if dry_run:
        if ui is not None:
            ui.msgbox(f"[DRY-RUN]\n$ {printable}")
        else:
            print(f"[pipeline-sh-client] $ {printable}")
            print("(dry-run) Skipping execution.")
        return
    print(f"[pipeline-sh-client] $ {printable}")
    subprocess.run(command, check=True)


def ensure_exists(path: Path, description: str) -> None:
    """Exit with a clear error message if the provided path is missing."""

    if not path.exists():
        raise FileNotFoundError(f"{description} not found: {path}")


def install_dependencies(pip_command: str, dry_run: bool) -> None:
    """Install project dependencies as described in the spec, from the project root."""
    project_root = PROJECT_DIR
    pyproject = project_root / "pyproject.toml"
    if not pyproject.exists():
        raise FileNotFoundError(f"pyproject.toml not found in {project_root}")

    commands = [
        [pip_command, "install", "--upgrade", "pip"],
        [pip_command, "install", "-e", ".[dev]"],
    ]

    for command in commands:
        run_command(command, dry_run=dry_run if dry_run else False) if dry_run else subprocess.run(command, cwd=str(project_root), check=True)


def build_download_command(dataset: str, dataset_root: Path, splits: Iterable[str]) -> List[str]:
    """Construct the dataset download command for a single dataset."""

    split_arg = ",".join(splits)
    return [
        "python",
        "-m",
        "wejepa.datasets.download",
        "--dataset-root",
        str(dataset_root),
        "--dataset-name",
        dataset,
        "--splits",
        split_arg,
    ]


def download_datasets(datasets: Iterable[str], dataset_root: Path, splits: Iterable[str], dry_run: bool) -> None:
    """Download one or more datasets sequentially."""

    ensure_exists(dataset_root, "Dataset root")
    for dataset in datasets:
        command = build_download_command(dataset, dataset_root, splits)
        run_command(command, dry_run=dry_run)



def build_pretrain_command(config: Path, datasets: Iterable[str], extra_args: Iterable[str]) -> List[str]:
    """Construct the pretraining command."""
    # if no config (e.g., empty string or ''), use the default config
    if not config or not Path(config).is_file():
        command = ["python", "-m", "wejepa.train.pretrain"]
    else:
        command = ["python", "-m", "wejepa.train.pretrain", "--config", str(config)]

    for dataset in datasets:
        command.extend(["--dataset", dataset])
    command.extend(extra_args)
    return command



def generate_slurm_script(
    output_path: Path,
    command: Sequence[str],
    job_name: str,
    nodes: int,
    cpus: int,
    mem: str,
    time: str,
    gpus: str,
    ext3_path: str,
    sif_path: str,
    account: str,
    mail_user: str,
    mail_type: str,
    output_log: str,
) -> None:
    """Render the Slurm script using the provided command and template."""

    # Ensure slurms directory exists
    output_path = SLURMS_DIR / output_path.name if not output_path.is_absolute() else output_path
    output_path.parent.mkdir(parents=True, exist_ok=True)
    ensure_exists(SLURM_TEMPLATE, "Slurm template")
    template = SLURM_TEMPLATE.read_text()

    replacements: Dict[str, str] = {
        "YourNameHere": job_name,
        "--nodes=1": f"--nodes={nodes}",
        "--cpus-per-task=2": f"--cpus-per-task={cpus}",
        "--mem=64GB": f"--mem={mem}",
        "--time=6:00:00": f"--time={time}",
        "--gres=gpu:1": f"--gres={gpus}",
        "YourEXT3PATH.ext3": ext3_path,
        "YourSIFPATH.sif": sif_path,
        "REPLACE THIS WITH YOUR COMMANDS": format_command(command),
    }

    if account:
        replacements["##SBATCH --account=pr_000_tandon_advanced"] = f"#SBATCH --account={account}"
    if mail_type:
        replacements["##SBATCH --mail-type=END"] = f"#SBATCH --mail-type={mail_type}"
    if mail_user:
        replacements["##SBATCH --mail-user=your.email@nyu.edu"] = f"#SBATCH --mail-user={mail_user}"
    if output_log:
        replacements["##SBATCH --output=log/slurm-%j.out"] = f"#SBATCH --output={output_log}"

    for needle, value in replacements.items():
        template = template.replace(needle, value)

    output_path.write_text(template)
    print(f"Generated Slurm script at {output_path}")


def submit_slurm(script_path: Path, dry_run: bool) -> None:
    """Submit the generated script via sbatch if available."""

    if not shutil.which("sbatch"):
        raise FileNotFoundError("sbatch command not found in PATH; cannot submit job.")

    run_command(["sbatch", str(script_path)], dry_run=dry_run)


def handle_install(args: argparse.Namespace) -> None:
    install_dependencies(args.pip_command, dry_run=args.dry_run)


def handle_download(args: argparse.Namespace) -> None:
    # Default to 'data' directory if not specified
    dataset_root = Path(args.dataset_root) if hasattr(args, 'dataset_root') and args.dataset_root else Path('data')
    download_datasets(args.datasets, dataset_root, args.splits, dry_run=args.dry_run)


def handle_pretrain(args: argparse.Namespace) -> None:
    command = build_pretrain_command(Path(args.config), args.datasets, args.extra_args)
    run_command(command, dry_run=args.dry_run)

    if args.slurm_path:
        slurm_path = Path(args.slurm_path)
        generate_slurm_script(
            slurm_path,
            command,
            job_name=args.job_name,
            nodes=args.nodes,
            cpus=args.cpus,
            mem=args.mem,
            time=args.time,
            gpus=args.gpus,
            ext3_path=args.ext3_path,
            sif_path=args.sif_path,
            account=args.account,
            mail_user=args.mail_user,
            mail_type=args.mail_type,
            output_log=args.output_log,
        )

        if args.submit:
            submit_slurm(slurm_path, dry_run=args.dry_run)


def handle_slurm(args: argparse.Namespace) -> None:
    if not args.command:
        raise ValueError("No command provided to embed in the Slurm script. Add arguments after --.")

    generate_slurm_script(
        Path(args.output),
        args.command,
        job_name=args.job_name,
        nodes=args.nodes,
        cpus=args.cpus,
        mem=args.mem,
        time=args.time,
        gpus=args.gpus,
        ext3_path=args.ext3_path,
        sif_path=args.sif_path,
        account=args.account,
        mail_user=args.mail_user,
        mail_type=args.mail_type,
        output_log=args.output_log,
    )

    if args.submit:
        submit_slurm(Path(args.output), dry_run=args.dry_run)


def handle_show(_: argparse.Namespace) -> None:
    ui = DialogUI()
    ui.markdownbox(ROOT / "README.md")

def add_common_slurm_args(parser: argparse.ArgumentParser) -> None:
    parser.add_argument("--job-name", default="wejepa-job", help="Job name for Slurm.")
    parser.add_argument("--nodes", type=int, default=1, help="Number of nodes.")
    parser.add_argument("--cpus", type=int, default=2, help="CPUs per task.")
    parser.add_argument("--mem", default="64GB", help="Memory allocation.")
    parser.add_argument("--time", default="6:00:00", help="Wall clock time (HH:MM:SS).")
    parser.add_argument("--gpus", default="gpu:1", help="GPU resource string, e.g., gpu:1 or gpu:rtx8000:4.")
    parser.add_argument("--ext3-path", default="YourEXT3PATH.ext3", help="Overlay EXT3 path for Singularity.")
    parser.add_argument("--sif-path", default="YourSIFPATH.sif", help="SIF image path for Singularity.")
    parser.add_argument("--account", help="Optional Slurm account directive.")
    parser.add_argument("--mail-user", help="Optional Slurm notification email.")
    parser.add_argument("--mail-type", help="Optional Slurm mail type (e.g., END, FAIL).")
    parser.add_argument("--output-log", help="Optional Slurm output log path.")


def build_parser() -> argparse.ArgumentParser:
    common = argparse.ArgumentParser(add_help=False)
    common.add_argument("--dry-run", action="store_true", help="Print commands without executing them.")

    parser = argparse.ArgumentParser(description=__doc__, parents=[common])
    subparsers = parser.add_subparsers(required=False)

    ui_parser = subparsers.add_parser("ui", parents=[common], help="Launch the dialog-based UI (default).")
    ui_parser.set_defaults(func=launch_dialog_ui)

    install_parser = subparsers.add_parser("install", parents=[common], help="Install project dependencies.")
    install_parser.add_argument(
        "--pip-command",
        default="pip",
        help="Pip command to run (e.g., pip or pip3).",
    )
    install_parser.set_defaults(func=handle_install)

    download_parser = subparsers.add_parser("download", parents=[common], help="Download one or more datasets.")
    download_parser.add_argument(
        "--datasets",
        nargs="+",
        required=True,
        help="Datasets to download (e.g., cifar100 imagenet).",
    )
    download_parser.add_argument("--dataset-root", default="data", help="Destination directory for downloads (default: data/).")
    download_parser.add_argument(
        "--splits",
        nargs="+",
        default=["train"],
        help="Dataset splits to download (e.g., train test train[:10]).",
    )
    download_parser.set_defaults(func=handle_download)

    pretrain_parser = subparsers.add_parser("pretrain", parents=[common], help="Launch pretraining locally or via Slurm.")
    pretrain_parser.add_argument("--config", required=True, help="Path to the training config file.")
    pretrain_parser.add_argument(
        "--datasets",
        nargs="+",
        default=[],
        help="Datasets to pass to the training script.",
    )
    pretrain_parser.add_argument(
        "--extra-args",
        nargs=argparse.REMAINDER,
        default=[],
        help="Additional arguments forwarded to the training command.",
    )
    pretrain_parser.add_argument("--slurm-path", help="Optional path to write a Slurm script.")
    pretrain_parser.add_argument("--submit", action="store_true", help="Submit generated Slurm script with sbatch.")
    add_common_slurm_args(pretrain_parser)
    pretrain_parser.set_defaults(func=handle_pretrain)

    slurm_parser = subparsers.add_parser(
        "slurm", parents=[common], help="Generate or submit a Slurm script for an arbitrary command."
    )
    slurm_parser.add_argument("--output", required=True, help="Where to write the Slurm script.")
    slurm_parser.add_argument(
        "command",
        nargs=argparse.REMAINDER,
        help="Command to execute inside the Slurm job (place after --).",
    )
    slurm_parser.add_argument("--submit", action="store_true", help="Submit generated Slurm script with sbatch.")
    add_common_slurm_args(slurm_parser)
    slurm_parser.set_defaults(func=handle_slurm)

    spec_parser = subparsers.add_parser("show", parents=[common], help="Print the HPC readme file.")
    spec_parser.set_defaults(func=handle_show)

    return parser


class DialogUI:
    """Wrapper around the ``dialog`` binary."""

    def __init__(self, dialog_bin: str = "dialog") -> None:
        self.dialog_bin = dialog_bin
        self.require_dialog()

    def require_dialog(self) -> None:
        if not shutil.which(self.dialog_bin):
            raise FileNotFoundError(
                "dialog binary not found. Install it (e.g., `apt-get install dialog`) and retry."
            )

    def _run(self, args: Sequence[str]) -> str:
        command = [self.dialog_bin, "--clear", "--stdout", *args]
        result = subprocess.run(command, text=True, capture_output=True)
        if result.returncode in {1, 255}:
            raise DialogCancelled()
        return result.stdout.strip()

    def menu(self, text: str, choices: Sequence[Tuple[str, str]]) -> str:
        flat: List[str] = []
        for tag, desc in choices:
            flat.extend([tag, desc])
        return self._run(["--menu", text, "20", "80", str(len(choices)), *flat])

    def checklist(self, text: str, choices: Sequence[Tuple[str, str]], preselected: Sequence[str] = ()) -> List[str]:
        flat: List[str] = []
        selected = set(preselected)
        for tag, desc in choices:
            status = "on" if tag in selected else "off"
            flat.extend([tag, desc, status])
        raw = self._run(["--separate-output", "--checklist", text, "22", "90", str(len(choices)), *flat])
        return [line for line in raw.splitlines() if line]

    def inputbox(self, text: str, default: str = "") -> str:
        return self._run(["--inputbox", text, "12", "80", default])

    def yesno(self, text: str, default_no: bool = False) -> bool:
        args = ["--yesno", text, "10", "70"]
        if default_no:
            args.append("--defaultno")
        try:
            self._run(args)
            return True
        except DialogCancelled:
            return False

    def msgbox(self, text: str) -> None:
        try:
            self._run(["--msgbox", text, "20", "80"])
        except DialogCancelled:
            pass

    def textbox(self, path: Path) -> None:
        try:
            self._run(["--textbox", str(path), "24", "90"])
        except DialogCancelled:
            pass

    def markdownbox(self, path: Path) -> None:
        """Display a markdown file as plain text in a dialog textbox, stripping most formatting."""
        try:
            if not path.exists():
                self.msgbox(f"File not found: {path}")
                return
            text = path.read_text(encoding="utf-8")
            # Simple markdown to plain text: strip headings, code blocks, emphasis, links
            import re
            text = re.sub(r"^#+ ", "", text, flags=re.MULTILINE)  # Remove headings
            text = re.sub(r"`([^`]*)`", r"\1", text)  # Inline code
            text = re.sub(r"\*\*([^*]+)\*\*", r"\1", text)  # Bold
            text = re.sub(r"\*([^*]+)\*", r"\1", text)  # Italic
            text = re.sub(r"!\[[^\]]*\]\([^)]*\)", "", text)  # Images
            text = re.sub(r"\[([^\]]+)\]\(([^)]+)\)", r"\1 (\2)", text)  # Links
            # Remove code blocks (```)
            text = re.sub(r"```[\s\S]*?```", "", text)
            # Optionally truncate if too long
            if len(text) > 20000:
                text = text[:20000] + "\n... (truncated) ..."
            # Write to a temp file for dialog textbox
            import tempfile
            with tempfile.NamedTemporaryFile("w", delete=False, encoding="utf-8") as tmp:
                tmp.write(text)
                tmp_path = tmp.name
            try:
                self._run(["--textbox", tmp_path, "24", "90"])
            finally:
                os.unlink(tmp_path)
        except DialogCancelled:
            pass


def prompt_slurm_parameters(ui: DialogUI) -> Dict[str, str | None]:
    params: Dict[str, str | None] = {}
    # Use config values as defaults if present
    params["job_name"] = ui.inputbox("Job name", config.get("last_slurm_job_name", "wejepa-job"))
    params["nodes"] = ui.inputbox("Number of nodes", config.get("last_slurm_nodes", "1"))
    params["cpus"] = ui.inputbox("CPUs per task", config.get("last_slurm_cpus", "2"))
    params["mem"] = ui.inputbox("Memory (e.g., 64GB)", config.get("last_slurm_mem", "64GB"))
    params["time"] = ui.inputbox("Wall time (HH:MM:SS)", config.get("last_slurm_time", "6:00:00"))
    params["gpus"] = ui.inputbox("GPU string (e.g., gpu:1 or gpu:rtx8000:4)", config.get("last_slurm_gpus", "gpu:1"))
    params["ext3_path"] = ui.inputbox("Overlay EXT3 path", config.get("last_slurm_ext3_path", "YourEXT3PATH.ext3"))
    params["sif_path"] = ui.inputbox("SIF path", config.get("last_slurm_sif_path", "YourSIFPATH.sif"))
    params["account"] = ui.inputbox("Account (optional)", config.get("last_slurm_account", ""))
    params["mail_user"] = ui.inputbox("Notification email (optional)", config.get("last_slurm_mail_user", ""))
    params["mail_type"] = ui.inputbox("Mail type (optional, e.g., END, FAIL)", config.get("last_slurm_mail_type", ""))
    params["output_log"] = ui.inputbox("Output log path (optional)", config.get("last_slurm_output_log", ""))

    # Save these values to config for next time
    config["last_slurm_job_name"] = params["job_name"]
    config["last_slurm_nodes"] = params["nodes"]
    config["last_slurm_cpus"] = params["cpus"]
    config["last_slurm_mem"] = params["mem"]
    config["last_slurm_time"] = params["time"]
    config["last_slurm_gpus"] = params["gpus"]
    config["last_slurm_ext3_path"] = params["ext3_path"]
    config["last_slurm_sif_path"] = params["sif_path"]
    config["last_slurm_account"] = params["account"]
    config["last_slurm_mail_user"] = params["mail_user"]
    config["last_slurm_mail_type"] = params["mail_type"]
    config["last_slurm_output_log"] = params["output_log"]
    save_config(config)
    return params


def prompt_dataset_selection(ui: DialogUI) -> List[str]:
    return ui.checklist("Select datasets", DATASET_CHOICES, preselected=["tsbpp/fall2025_deeplearning"])


def prompt_dry_run(ui: DialogUI, config_key: str = None) -> bool:
    # config_key: e.g. 'last_install_dry_run', 'last_download_dry_run', etc.
    default = False
    if config_key is not None:
        default = bool(config.get(config_key, False))
        print(f"User preference for {config_key}: {default}")
    # If default is True, highlight 'Yes' (dry-run) by default; if False, highlight 'No' by default
    result = ui.yesno("Enable dry-run (print commands only)?")
    print(f"User selected dry-run: {result}")
    # result is True if user selects 'Yes', False if 'No'
    if config_key is not None:
        config[config_key] = result
        save_config(config)
    print(f"[pipeline-py-client] Dry-run mode: {'enabled' if result else 'disabled'}")
    return result


def dialog_install(ui: DialogUI) -> None:
    try:
        pip_command = ui.inputbox("Pip command", "pip")
        dry_run = prompt_dry_run(ui, config_key="last_install_dry_run")
    except DialogCancelled:
        return
    config["last_pip_command"] = pip_command
    save_config(config)
    commands = [
        [pip_command, "install", "--upgrade", "pip"],
        [pip_command, "install", "-e", ".[dev]"],
    ]
    if dry_run:
        msg = "[DRY-RUN] The following commands would be run:\n"
        msg += "\n".join(["$ " + format_command(cmd) for cmd in commands])
        ui.msgbox(msg)
    else:
        install_dependencies(pip_command, dry_run=False)


def dialog_download(ui: DialogUI) -> None:
    try:
        # input full path to dataset root 
        dataset_root = Path(ui.inputbox("Dataset root (must exist)", 
                                        config.get("last_dataset_root", str(DATA_DIR))))
        datasets = prompt_dataset_selection(ui)
        if not datasets:
            ui.msgbox("No datasets selected. Nothing to do.")
            return
        splits_raw = ui.inputbox("Splits (comma separated)", "train")
        splits = [split.strip() for split in splits_raw.split(",") if split.strip()]
        dry_run = prompt_dry_run(ui, config_key="last_download_dry_run")
    except DialogCancelled:
        return

    config["last_dataset_root"] = str(dataset_root)
    config["last_datasets"] = datasets
    config["last_splits"] = splits
    save_config(config)

    try:
        for dataset in datasets:
            command = build_download_command(dataset, dataset_root, splits)
            run_command(command, dry_run=dry_run, ui=ui)
    except Exception as exc:  # pragma: no cover - surfaced to the user
        ui.msgbox(f"Download failed: {exc}")


def dialog_pretrain(ui: DialogUI) -> None:
    import json
    try:
        # List config files in experiments/configs
        configs_dir = CONFIGS_DIR
        config_files = [f for f in configs_dir.iterdir() if f.is_file() and f.suffix == ".json"]
        if not config_files:
            ui.msgbox(f"No config files found in {configs_dir}")
            return
        config_choices = []

        # default settings
        default_config = "default (wejepa.train.pretrain default settings)"
        config_choices.append(("default", default_config))

        for f in config_files:
            desc = ""
            try:
                with open(f, "r") as fp:
                    j = json.load(fp)
                # Extract requested keys
                dataset_name = j.get("data", {}).get("dataset_name")
                image_size = j.get("data", {}).get("image_size")
                model = j.get("model", {})
                backbone = model.get("classification_backbone")
                img_size = model.get("img_size")
                num_class = model.get("classification_num_classes")
                pretrained = model.get("classification_pretrained")
                desc_items = []
                if dataset_name:
                    if len(str(dataset_name)) > 5:
                        desc_items.append(str(dataset_name)[:5])
                    else:
                        desc_items.append(str(dataset_name))
                if image_size: desc_items.append(f"{image_size}")
                if backbone: desc_items.append(f"{backbone}")
                if img_size: desc_items.append(f"{img_size}")
                if num_class: desc_items.append(f"{num_class}")
                if pretrained is not None: desc_items.append(f"{pretrained}")
                if desc_items:
                    desc += " [" + ", ".join(desc_items) + "]"
            except Exception:
                pass
            config_choices.append((f.name.split(".")[0], desc))
        selected_config = ui.menu("Select a config file\n" +
                                    "d: dataset, m: model\n" +
                                    "[d:name, d:img_size, m:backbone, m:img_size, m:num_class, m:pretrained]", 
                                    config_choices)
        config_path = configs_dir / selected_config
        config_path = str(config_path) + ".json" if selected_config != "default" else ""

        print(f"User selected config: {config_path}")
        datasets = prompt_dataset_selection(ui)
        extra_args_raw = ui.inputbox("Additional args (space separated, optional)", "")
        extra_args = extra_args_raw.split() if extra_args_raw else []
        dry_run = prompt_dry_run(ui, config_key="last_pretrain_dry_run")
    except DialogCancelled:
        return

    config["last_pretrain_config"] = str(config_path)
    config["last_pretrain_datasets"] = datasets
    config["last_pretrain_extra_args"] = extra_args
    save_config(config)

    try:
        command = build_pretrain_command(Path(config_path), datasets, extra_args)
    except Exception as exc:  # pragma: no cover - surfaced to the user
        ui.msgbox(f"Could not build pretraining command: {exc}")
        return

    try:
        run_command(command, dry_run=dry_run, ui=ui)
    except Exception as exc:  # pragma: no cover - surfaced to the user
        ui.msgbox(f"Pretrain launch failed: {exc}")
        return

    try:
        if ui.yesno("Generate a Slurm script for this pretrain run?", default_no=True):
            params = prompt_slurm_parameters(ui)
            slurm_path = Path(
                ui.inputbox("Where should the Slurm script be written?", "pretrain.slurm")
            )
            generate_slurm_script(
                slurm_path,
                command,
                job_name=params["job_name"] or "wejepa-job",
                nodes=int(params["nodes"] or 1),
                cpus=int(params["cpus"] or 2),
                mem=params["mem"] or "64GB",
                time=params["time"] or "6:00:00",
                gpus=params["gpus"] or "gpu:1",
                ext3_path=params["ext3_path"] or "YourEXT3PATH.ext3",
                sif_path=params["sif_path"] or "YourSIFPATH.sif",
                account=params.get("account"),
                mail_user=params.get("mail_user"),
                mail_type=params.get("mail_type"),
                output_log=params.get("output_log"),
            )
            if ui.yesno("Submit with sbatch now?", default_no=False):
                submit_slurm(slurm_path, dry_run=dry_run)
    except DialogCancelled:
        return
    except Exception as exc:  # pragma: no cover - surfaced to the user
        ui.msgbox(f"Slurm generation/submission failed: {exc}")


def dialog_slurm(ui: DialogUI) -> None:
    try:
        raw_command = ui.inputbox("Command to wrap (e.g., python -m wejepa.datasets.download ...)")
        if not raw_command:
            ui.msgbox("No command provided. Returning to menu.")
            return
        params = prompt_slurm_parameters(ui)
        slurm_path = Path(ui.inputbox("Where should the Slurm script be written?", "job.slurm"))
        dry_run = False
        # dry_run = prompt_dry_run(ui, config_key="last_slurm_dry_run")
    except DialogCancelled:
        return

    try:
        command = raw_command.split()
        if dry_run:
            ui.msgbox(f"[DRY-RUN] Would wrap this command in Slurm script:\n$ {' '.join(command)}")
        generate_slurm_script(
            slurm_path,
            command,
            job_name=params["job_name"] or "wejepa-job",
            nodes=int(params["nodes"] or 1),
            cpus=int(params["cpus"] or 2),
            mem=params["mem"] or "64GB",
            time=params["time"] or "6:00:00",
            gpus=params["gpus"] or "gpu:1",
            ext3_path=params["ext3_path"] or "YourEXT3PATH.ext3",
            sif_path=params["sif_path"] or "YourSIFPATH.sif",
            account=params.get("account"),
            mail_user=params.get("mail_user"),
            mail_type=params.get("mail_type"),
            output_log=params.get("output_log"),
        )
        if ui.yesno("Submit with sbatch now?", default_no=True):
            submit_slurm(slurm_path, dry_run=dry_run)
    except Exception as exc:  # pragma: no cover - surfaced to the user
        ui.msgbox(f"Slurm generation/submission failed: {exc}")


def launch_dialog_ui(_: argparse.Namespace | None = None) -> None:
    ui = DialogUI()
    main_menu_choices = (
        ("install", "Install dependencies (pip install -e .[dev])"),
        ("download", "Download datasets"),
        ("pretrain", "Launch pretraining and optional Slurm"),
        ("slurm", "Generate/submit a Slurm script for any command"),
        ("help", "Show project README.md as help"),
        ("quit", "Exit"),
    )

    while True:
        try:
            selection = ui.menu("WeJEPA pipeline client", main_menu_choices)
        except DialogCancelled:
            break

        if selection == "install":
            dialog_install(ui)
        elif selection == "download":
            dialog_download(ui)
        elif selection == "pretrain":
            dialog_pretrain(ui)
        elif selection == "slurm":
            dialog_slurm(ui)
        elif selection == "help":
            readme_path = ROOT / "README.md"
            if readme_path.exists():
                ui.markdownbox(readme_path)
            else:
                ui.msgbox("README.md not found.")
        elif selection == "quit":
            break


def parse_and_run(argv: Sequence[str] | None = None) -> None:
    if argv is None:
        argv = sys.argv[1:]

    parser = build_parser()
    if not argv:
        launch_dialog_ui()
        return

    args = parser.parse_args(list(argv))
    if hasattr(args, "func"):
        args.func(args)
    else:
        launch_dialog_ui()


def main(argv: Sequence[str] | None = None) -> None:
    parse_and_run(argv)


if __name__ == "__main__":
    main()
